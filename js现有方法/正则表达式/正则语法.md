[正则的基本语法](https://juejin.im/post/5b5db5b8e51d4519155720d2#heading-1)

# 基本语法
+ 单个字符：数字，数字或字母，非数字和字母，空格和tab，非空格和tab，任何字符
+ 数量：0个或1个，1个或更多个，0个或1个，在一个范围内，匹配出现n次
+ 位置：行开头，行结尾，单词的结界

# 字符分类（中括号符号[]）
+ 基本用法：表示或逻辑，比如[abc]表示a或者b或者c,在方括号里，特殊字符是不需要转义的
+ 特殊语法：-,^和. 。 -是第一个字符时，表示它本身，放在中间是表示区间，比如[a-z]表示从a到z。^放在外面表示一行的开头，^放在[]里面，表示取反。比如[^ab]，表示不是a且不是b。点符号.在[]里不需要转义，就是点号本身。在外面直接使用匹配任何字符；在外面表示点号本身，需要转义 \\.
+ ()和[]一样，也可以用于或语法，比如，(a|b)的意思是a或者b

# 分组捕获
+ 匹配到的组。比如/\d{3}-(\d{3})-\(\d{4})/  匹配 “212-555-1234” 时 Group0是212-555-1234，Group1是第一个括号555，Group2是第二个括号1234
+ 选择分组。方法一：使用$符，$1表示555，$2表示1234  方法二： 使用反斜杠\，\1表示555，\2表示1234.
+ $和\反斜杠的区别。$ 是在替换的时候进行标志或选择。但是对于表达式本身，用\ 。

# JavaScript的应用(string中的应用)
+ reg.test() 正则表达式自身的test方法，是否包含，包含返回true，不包含返回false  reg.test(str)
+ str.match(reg) 正则表达式，返回第一个可以匹配的序列。加了g修饰符后，返回所有匹配到的序列。无g修饰符时，会返回所有子项（$0,$1...），有g修饰时，只返回匹配所有序列，不放子项。
+ reg.exec()方法 每执行一次，返回匹配序列和其子项的数组。直到返回的是null。如果返回nall后，还继续执行，将会从字符串开头重新执行一次（亲测如此）
+ str.split()方法 split参数可以传正则表达式，如 str.split(/[\s,]+/)
+ str.replace(reg, replaceStr|function)方法 第一个参数是正则表达式，是匹配的内容，第二个参数是替换的字符串或回调函数。
  tips: 1. 不会修改原字符串，只会返回修改后的字符串； 2. 正则reg如果没有用g，和match一样，只会替换第一个  3. function(match,group1,group2) 回调函数的第一个参数是匹配到的内容，后面的参数, 如果进行分组匹配了，则接着的参数是子项1，子项2（一直到子项n），然后是 匹配字符串对应的索引位置，然后是 原始字符串。所以，function的参数个数是不固定的

# 练习：
1. 匹配所有电话号码包括 915-134-3122   643.123.3355  (120)867-5509
  分析：一共10位，如果只匹配第一种：\d{3}-\d{3}-\d{4}，如果只匹配第二种：\d{3}.\d{3}.\d{4} -和.是或的关系，用分类字符[],\d{3}[-.]\d{3}[-.]\d{4}把括号也加进去 \(?\d{3}[-.)]\d{3}[-.]\d{4} 但是我觉得这种写法还不够严谨，更好的写法是用括号区分 reg = /(^\\(\d{3}\\)\d{3}-)|(^\d{3}[-.]\d{3}[-.])\d{4}/ 拆分下就是，前面带括号和不带括号分开

2. 以.net,.edu,.com结尾的邮箱
  分析：邮箱是数字或字母\w开头，接@,然后继续数字或字母 \w，然后.net等结尾。 reg = /^\w+@\w+\.(net|edu|com)$/

3. 有个名单列表，名和姓是反的，交换过来
    shiffina, Danial
    shifafl, Danial
    shquer, Danny
    reg = (\w+),\s(\w+)  replace: $2 $1  注意这里第一个括号是$1，$0是整个

4. 匹配markdown中的link标签，替换为html标签
    [google](http://google.com)[test]
    [itp](http://itp.nyu.edu)
    分析：需要从原表达式中匹配字符串出来，进行替换，因此用$+数字的方式。方括号后面紧跟一个括号的形式。\[.*\],但是.是贪婪的，会把“[google](http://google.com)[test]”全部匹配，因此需要去掉贪婪属性，在遇到第一个]时就要停下来。将?放在数量修饰符后面，就能去掉贪婪属性。因此“[google](http://google.com)”匹配为 reg: /\[.*?\]\(http://.*?\)/ 
    由于要把方括号和圆括号里的字符拿出来，因此给他们加上括号，/\[(.*?)\]\((http://.*?)\)/ 在replace <a href="$2">$1</a>

5. 匹配连续序列 
  This is is a dog dog under the tree tree, do you know? 匹配其中的is is, dog dog, tree tree 
  分析：匹配的是表达式自身，用反斜杠+数字方式。 (\w+)\s\1 这段表达式会把 This 中的is也选择，因此要加\b修饰符，\b(\w+)\s\1\b

6. 将下面一句话中的英文单词提取出来   let str = "unicorns and rainbows And, Cupcakes";
    分析： 首先想到的是split, str.split(" "); 但是会多一个逗号，用正则表达式str.split(/[,.!?\s]+/)

7. 将下列句子中的替换成一个double  比如 x->xx
